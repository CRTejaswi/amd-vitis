%
% Copyright (C) 2023, Advanced Micro Devices, Inc. All rights reserved.
% SPDX-License-Identifier: MIT
%
% Author: Richard Buz

% Generates test vector files, for a single image, which are used to verify 
% bilinear interpolation performed via AIE simulation.

% Inputs to the function are:
%        cores:   Specifies the number of parallel bilinear interpolation
%                 kernels. Test vector input and output is generated for 
%                 each individual kernel. The default value is 1.
%        frmslct: This is an index used to select an individual image frame
%                 from file bli_coords.mat. The default is 40.

% Generated files: Files are created in directory ../aie/data/
%
%        An input file is generated for each individual kernel, The naming
%        convention is input_1.txt, input_2.txt, input_3.txt, ...
%        Each interpolated pixel is associated with a sequence of eight
%        values. The order is: four input pixel values, xfrac, yfrac, 
%        output pixel index, and one unused value. 
%
%        An output file is generated for each kernel and is used to compare
%        with AIE output. The naming convention is output_1_ref.txt,
%        output_2_ref.txt, output_3_ref.txt, ...
%        Each pixel is represented by a pair of consecutive values in the
%        output file, The first value is a 32b output pixel index and the 
%        second is the interpolated pixel value. 
% 
%        For all files, floating point values are cast as 'int32' so they 
%        can be written to text files without loss of precision.
%
%        An additional file named config.h is also generated in directory 
%        ../aie/src, and is necessary to compile the AIE code. The file
%        contains two macro definitions. The first specifies the number
%        of parallel cores used. The second specifies the number of times 
%        the graph needs to be run to process the entire image.

function genvectors_bilinear_interp(cores, frmslct)

% assign default arguments if necessary
if nargin < 2
    frame_select = 40;
else
    frame_select = frmslct;
end

if nargin == 0
    ncore = 1;
else
    ncore = cores;
end

% Load data generated by image_transform.m and select a frame
load('bli_coords.mat', 'I', 'Xq', 'Yq');
Xq  = Xq(:,:,frame_select);
Yq  = Yq(:,:,frame_select);

% Use camera image as a lookup table. 
% Make indicies integers and determine the image size bounds.
[ysz, xsz] = size(I);
lut_xmin = 0;
lut_xmax = xsz - 1;
lut_ymin = 0;
lut_ymax = ysz - 1;

% Convert LUT to single precision float format and initialize output image
% to all zeros.
ImLUT = single(I(:));
ImgOut = single(zeros(size(Yq,1) * size(Xq,2), 1));
   
in_bnd_cnt = 0;  % counts interpolated pixels, excludes pixels requiring extrapolation

% AIE kernel is set to process blocks of 256 pixels. Make sure there is
% enough input data so the simulation doesn't hang.
max_pxl_per_proc = 256 * ceil(size(Yq,1) * size(Xq,2) / ncore / 256);
input_tv = repmat(typecast(realmax('single'), 'int32'), 8*max_pxl_per_proc, ncore);
output_tv = repmat(typecast(realmax('single'), 'int32'), 2*max_pxl_per_proc, ncore);

% process the output pixels in sequence
ismp_idx = 1;
osmp_idx = 1;
core_idx = 1;
num_krnl_pxl = 1;

for ix = 1:size(Xq,2)
    for iy = 1:size(Yq,1)
        % get query coordinates
        xval = Xq(iy,ix);
        yval = Yq(iy,ix);

        % Only process interpolated points. Points requiring extrapolation are set to
        % zero.
        is_interp = xval >= lut_xmin && xval < lut_xmax && yval >= lut_ymin && yval < lut_ymax;

        if is_interp
            % get reference point data from camera image
            x1 = int32(floor(xval));
            y1 = int32(floor(yval));   

            % four values used in interpolation, taken from camera image
            Q11 = ImLUT(x1*(lut_ymax+1)+y1+1);
            Q12 = ImLUT(x1*(lut_ymax+1)+y1+2);
            Q21 = ImLUT((x1+1)*(lut_ymax+1)+y1+1);
            Q22 = ImLUT((x1+1)*(lut_ymax+1)+y1+2);

            % fractional part for interpolation
            xfrac = single(xval - floor(xval));
            yfrac = single(yval - floor(yval));

            % perform bilinear interpolation
            blint_in = [Q11 Q12 Q21 Q22 xfrac yfrac];
            pxl_intrp = blint(blint_in,3);

            % write test vector data
            output_idx = int32(size(Yq,1)*(ix-1) + iy - 1);
            ImgOut(output_idx + 1) = pxl_intrp;
            input_tv((ismp_idx:ismp_idx+7),core_idx) = [typecast(blint_in', 'int32'); output_idx; int32(0)];
            output_tv((osmp_idx:osmp_idx+1),core_idx) = [output_idx; typecast(pxl_intrp, 'int32')];

            % update counters
            in_bnd_cnt = in_bnd_cnt + 1;
            core_idx = core_idx + 1;
            if core_idx > ncore
                ismp_idx = ismp_idx + 8;
                osmp_idx = osmp_idx + 2;
                core_idx = 1;
                num_krnl_pxl = num_krnl_pxl + 1;
            end
        end
    end
end

% determine number of kernel calls required
if core_idx == 1
    num_krnl_pxl = num_krnl_pxl - 1;
end
num_krnl_call = ceil(num_krnl_pxl / 256);

% create config.h file
fid = fopen('../aie/src/config.h','w');
fprintf(fid, ['//\n// Copyright (C) 2023, Advanced Micro Devices, Inc. All ' ...
              'rights reserved.\n// SPDX-License-Identifier: MIT\n//\n' ...
              '// Author: Richard Buz\n\n#pragma once\n\n#define\tNCORE\t%d\n' ...
              '#define\tNRUN\t%d\n'],ncore,num_krnl_call);
fclose(fid);

% create input test vectors
input_tv(8*256*num_krnl_call+1:end,:) = [];
for idx = 1:ncore
    fname = sprintf('../aie/data/input_%d.txt',idx);
    fid = fopen(fname,'w');
    if fid > 0
        itv = reshape(input_tv(:,idx),2,length(input_tv(:,idx))/2);
        fprintf(fid,'%d %d\n',itv);
        fclose(fid);
    end
end

% create output test vectors
output_tv(2*256*num_krnl_call+1:end,:) = [];
for idx = 1:ncore
    fname = sprintf('../aie/data/output_%d_ref.txt',idx);
    fid = fopen(fname,'w');
    if fid > 0
        otv = reshape(output_tv(:,idx),2,length(output_tv(:,idx))/2);
        fprintf(fid,'%d %d\n',otv);
        fclose(fid);
    end
end

% setup comparison to MATLAB interp2 function
[Xref, Yref] = meshgrid(0:xsz-1,0:ysz-1);
Imgld = interp2(Xref,Yref,double(I),Xq,Yq,'linear',0);
ImgOut = reshape(ImgOut, size(Yq,1), size(Xq,2));
save golden_ref.mat Imgld

% display result
fprintf('Number of output pixels interpolated = %d out of %d (%8.5f %%)\n', ...
    in_bnd_cnt, size(Yq,1)*size(Xq,2), 100*in_bnd_cnt/(size(Yq,1)*size(Xq,2)));
subplot(1,3,1);
imshow(double(I)/255)
title('Camera Image')
subplot(1,3,2);
imshow(ImgOut/255)
title('Bilinear Interpolation (Single Precision)')
subplot(1,3,3);
imshow(Imgld/255)
title('Golden Reference (Double Precision)')

% calculate error
err = abs(ImgOut - Imgld);
max_err = max(err(:));
ms_err = mean(err(:).^2);
fprintf('Maximum pixel error is %.9f\n', max_err)
fprintf('Mean square pixel error is %.9f\n', ms_err)
